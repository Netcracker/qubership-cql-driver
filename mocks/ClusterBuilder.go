// Code generated by mockery v2.40.0. DO NOT EDIT.

package mocks

import (
	cql "github.com/Netcracker/qubership-cql-driver"
	gocql "github.com/gocql/gocql"

	mock "github.com/stretchr/testify/mock"
)

// ClusterBuilder is an autogenerated mock type for the ClusterBuilder type
type ClusterBuilder struct {
	mock.Mock
}

// Build provides a mock function with given fields:
func (_m *ClusterBuilder) Build() cql.Cluster {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Build")
	}

	var r0 cql.Cluster
	if rf, ok := ret.Get(0).(func() cql.Cluster); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cql.Cluster)
		}
	}

	return r0
}

// WithConnectTimeout provides a mock function with given fields: connectTimeout
func (_m *ClusterBuilder) WithConnectTimeout(connectTimeout int) cql.ClusterBuilder {
	ret := _m.Called(connectTimeout)

	if len(ret) == 0 {
		panic("no return value specified for WithConnectTimeout")
	}

	var r0 cql.ClusterBuilder
	if rf, ok := ret.Get(0).(func(int) cql.ClusterBuilder); ok {
		r0 = rf(connectTimeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cql.ClusterBuilder)
		}
	}

	return r0
}

// WithConsistency provides a mock function with given fields: consistency
func (_m *ClusterBuilder) WithConsistency(consistency gocql.Consistency) cql.ClusterBuilder {
	ret := _m.Called(consistency)

	if len(ret) == 0 {
		panic("no return value specified for WithConsistency")
	}

	var r0 cql.ClusterBuilder
	if rf, ok := ret.Get(0).(func(gocql.Consistency) cql.ClusterBuilder); ok {
		r0 = rf(consistency)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cql.ClusterBuilder)
		}
	}

	return r0
}

// WithHost provides a mock function with given fields: host
func (_m *ClusterBuilder) WithHost(host ...string) cql.ClusterBuilder {
	_va := make([]interface{}, len(host))
	for _i := range host {
		_va[_i] = host[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WithHost")
	}

	var r0 cql.ClusterBuilder
	if rf, ok := ret.Get(0).(func(...string) cql.ClusterBuilder); ok {
		r0 = rf(host...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cql.ClusterBuilder)
		}
	}

	return r0
}

// WithKeyspace provides a mock function with given fields: keyspace
func (_m *ClusterBuilder) WithKeyspace(keyspace string) cql.ClusterBuilder {
	ret := _m.Called(keyspace)

	if len(ret) == 0 {
		panic("no return value specified for WithKeyspace")
	}

	var r0 cql.ClusterBuilder
	if rf, ok := ret.Get(0).(func(string) cql.ClusterBuilder); ok {
		r0 = rf(keyspace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cql.ClusterBuilder)
		}
	}

	return r0
}

// WithPassword provides a mock function with given fields: password
func (_m *ClusterBuilder) WithPassword(password func() string) cql.ClusterBuilder {
	ret := _m.Called(password)

	if len(ret) == 0 {
		panic("no return value specified for WithPassword")
	}

	var r0 cql.ClusterBuilder
	if rf, ok := ret.Get(0).(func(func() string) cql.ClusterBuilder); ok {
		r0 = rf(password)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cql.ClusterBuilder)
		}
	}

	return r0
}

// WithPort provides a mock function with given fields: port
func (_m *ClusterBuilder) WithPort(port int) cql.ClusterBuilder {
	ret := _m.Called(port)

	if len(ret) == 0 {
		panic("no return value specified for WithPort")
	}

	var r0 cql.ClusterBuilder
	if rf, ok := ret.Get(0).(func(int) cql.ClusterBuilder); ok {
		r0 = rf(port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cql.ClusterBuilder)
		}
	}

	return r0
}

// WithRootCertPath provides a mock function with given fields: rootCertPath
func (_m *ClusterBuilder) WithRootCertPath(rootCertPath string) cql.ClusterBuilder {
	ret := _m.Called(rootCertPath)

	if len(ret) == 0 {
		panic("no return value specified for WithRootCertPath")
	}

	var r0 cql.ClusterBuilder
	if rf, ok := ret.Get(0).(func(string) cql.ClusterBuilder); ok {
		r0 = rf(rootCertPath)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cql.ClusterBuilder)
		}
	}

	return r0
}

// WithTLSEnabled provides a mock function with given fields: tlsEnabled
func (_m *ClusterBuilder) WithTLSEnabled(tlsEnabled bool) cql.ClusterBuilder {
	ret := _m.Called(tlsEnabled)

	if len(ret) == 0 {
		panic("no return value specified for WithTLSEnabled")
	}

	var r0 cql.ClusterBuilder
	if rf, ok := ret.Get(0).(func(bool) cql.ClusterBuilder); ok {
		r0 = rf(tlsEnabled)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cql.ClusterBuilder)
		}
	}

	return r0
}

// WithTimeout provides a mock function with given fields: timeout
func (_m *ClusterBuilder) WithTimeout(timeout int) cql.ClusterBuilder {
	ret := _m.Called(timeout)

	if len(ret) == 0 {
		panic("no return value specified for WithTimeout")
	}

	var r0 cql.ClusterBuilder
	if rf, ok := ret.Get(0).(func(int) cql.ClusterBuilder); ok {
		r0 = rf(timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cql.ClusterBuilder)
		}
	}

	return r0
}

// WithUser provides a mock function with given fields: user
func (_m *ClusterBuilder) WithUser(user string) cql.ClusterBuilder {
	ret := _m.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for WithUser")
	}

	var r0 cql.ClusterBuilder
	if rf, ok := ret.Get(0).(func(string) cql.ClusterBuilder); ok {
		r0 = rf(user)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cql.ClusterBuilder)
		}
	}

	return r0
}

// NewClusterBuilder creates a new instance of ClusterBuilder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClusterBuilder(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClusterBuilder {
	mock := &ClusterBuilder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
